Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?  
**Ответ.** ``public``, если модификатор доступа не указан используется модификатор по умолчанию(``package-private``)  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html 

Что является членами класса?  
**Ответ.** Членами класса являются его поля и методы, вложенные классы и вложенные интерфейсы.        
**Источник.** Блинов "Java Методы программирования" 2013 глава 3
 
Что еще можно определить в классе кроме членов?  
**Ответ.** Конструкторы, блоки инициализации 

Какие уровни доступа есть у членов класса?  
**Ответ.**      
``private`` - член класса доступен только из кода в том же классе;       
``protected`` - доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах;       
``public`` - Поля и методы видны другим классам из текущего пакета и из внешних пакетов;         
по умолчанию(``package-private``) - поля или методы видны всем классам в текущем пакете.   
**Источник.** Блинов "Java from EPAM" 2020 глава 3  
 
Какие модификаторы необходимы для определения константы:
1. класса,
2. экземпляра класса?  

**Ответ.** Для определения константы класса необходимы модификаторы ``static`` и ``final``. Для экземпляра класса - ``final``  
**Источник.** Блинов "Java from EPAM" 2020 глава 3

Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:
```java
class SomeClass {
    private int a;
    private final int b;
    private static int c;
    private static final int D;
}
```
Как можно назвать данные поля в зависимости от комбинации модификаторов ``static`` и ``final``?  
**Ответ.**  
a - Переменная экземпляра класса  
b - Константа экземпляра класса  
c - Переменная класса  
d - Константа класса   
 
Может ли класс не иметь ни одного конструктора? Почему?  
**Ответ.** Класс всегда имеет как минимум один конструктор. Если он не определен явно, то создается автоматически. Этот конструктор пустой и не делает ничего, кроме вызова конструктора суперкласса.    
**Источник.** Блинов "Java from EPAM" 2020
 
Перечислите отличия конструктора от метода.  
**Ответ.**
1. Конструктор не возвращает значение
2. Название конструктора совпадает с именем класса
3. Конструктор вызывается не просто по имени, а только вместе с ключевым словом ``new`` при создании экземпляра класса  
4. Если конструктор явно не определен, то он создается автоматически 
5. Конструктор не может быть объявлен как ``static``, ``final``, ``abstract``, ``synchronized``, ``native``.  
**Источник.** Блинов "Java from EPAM" 2020
 
Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?  
**Ответ.** Используя ключевое слово ``this``, можно строить одни конструкторы на основе использования возможностей других, при этом ``this`` должен быть в первой строчке конструктора.  
**Источник.** Блинов "Java from EPAM" 2020  

Как и в каком месте можно вызвать конструктор суперкласса?  
**Ответ.** Вызов конструктора суперкласса должен быть первой строкой в конструкторе подкласса. Синтаксис вызова конструктора суперкласса: ``super()`` или же: ``super (parameter list)``. С ``super()`` вызывается конструктор суперкласса без аргументов. С ``super(parameter list)`` вызывается конструктор суперкласса с соответствующим списком параметров.  Если конструктор не вызывает явно конструктор суперкласса, компилятор Java автоматически вставляет вызов в конструктор суперкласса без аргументов.     
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/super.html
 
Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?  
**Ответ.** Компилятор автоматически добавляет код вызова конструктора суперкласса без аргументов.

Можно ли одновременно использовать конструкции ``this()`` и ``super()`` в одном и том же конструкторе?
Обоснуйте ответ.  
**Ответ.** Внутри конструктора this и super должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст сообщение об ошибке. Из чего следует, что в одном конструкторе не может быть одновременно и ``this()``, и ``super()``.    
**Источник.** https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java    

Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?  
**Ответ.**  Может.  Определение конструктора с модификатором ``private`` говорит о том, что только собственный класс (как в классе, в котором определен ``private`` конструктор) может создавать экземпляр класса, и ни один другой вызывающий не может этого делать. Есть две возможные причины, по которым можно было бы использовать ``privat ``: во первых, вы вообще не хотите создавать какие – либо объекты вашего класса, а во вторых, вы хотите, чтобы объекты создавались только внутри вашего класса-например, только создавались в вашем классе.  
**Источник.** http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.10         

Какие модификаторы может иметь конструктор?  
**Ответ.** ``private``,``protected``,``public``, без явного указания используется модификатор по умолчанию(``package-private``)  
**Источник.** И. Блинов. Глава 3 70 стр.

Конструктор принадлежит классу или экземпляру класса?  
**Ответ.** Принадлежит классу.  
**Источник.** И. Блинов. Глава 3 70 стр.

Можно ли наследовать конструктор?
Если да, то приведите примеры.  
**Ответ.** Конструкторы не являются членами, поэтому они не наследуются подклассом, но конструктор суперкласса может быть вызван из подкласса.  
**Источник.** И. Блинов. Глава 3.

Какой тип возвращаемого конструктором значения?  
**Ответ.** Конструктор не имеет возвращаемого типа.  
**Источник.** И. Блинов. Глава 3 70 стр.  

Дан класс.
```java
class Null {
	//фрагмент 1
	Null Null() {
		return null;
	}
	//фрагмент 2
	Null() {
		return null;
	}
}
```
В каком фрагменте ошибка компиляции? 
Удалите этот фрагмент полностью. 
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.  
**Ответ.** Ошибка компиляции в фрагменте 2. 
```java
class Null {
	//фрагмент 1
	Null Null() {
		return null;
	}
}
```
В Фрагменте 1 создается метод ``Null()``, тип возвращаемого значения ``Null``, результат возвращения ``null``.     
Функционал класса:
```java
public class Main
{
    public static void main(String[] args) {
        Null n = new Null();
        n.Null();
    }
}
```
Имя метода совпадает с именем класа - это некрасиво, но не запрещено. Нельзя объявить данный метод в нижнем регистре т.к ``null`` - зарезервированное слово.        

Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?  
**Ответ.** Конструктор не имеет возвращаемого типа, им не может быть даже тип ``void``, если возвращается тип ``void``, то это уже не конструктор а метод, несмотря на совпадение с именем класса.  
**Источник.** И. Блинов. Глава 3 70 стр.


Дан класс.
```java
class Name {
	String name;
	Name() {
		this(makeRandomName());
	}
	Name(String name) {
		super();
		this.name = name;
	}
	String makeRandomName() {
		int k = (int) (Math.random() * 3);
		String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
		return name;
	}
	public String toString() {
		return name;
	}
	public static void main(String[] args) {
		System.out.println(new Name());
	}
}
```
Объясните причину ошибки компиляции. 
Предложите минимум 2 способа исправления ошибки, использовать метод makeRandomName() обязательно.  
**Ответ.** Невозможно сослаться на ``Name.makeRandomName`` до вызова конструктора супертипа. Метод ```String makeRandomName()``` не может быть вызван до создания объекта.
Исправление данной ошибки можно добавив методу ``makeRandomName()``, ключевое слово ``static``. Или создавая в конструкторе объект класса ``this(new Name("").makeRandomName()) ``

Дан класс.
```java
class Int {
	int i;
	void inc(Int param) {
		//param = new Int();
		param.i++;
	}
	public static void main(String[] args) {
		Int obj = new Int();
		obj.inc(obj);
		System.out.println(obj.i);
	}
}
```
Изменится ли результат, если убрать комментарий?
Объясните, почему?  
**Ответ.** Измениться, т.к когда мы создаем новый объект класса Int в методе inc(), данный объект существует только в рамках данного метода, т.е в методе `inc(Int param)` param переменная уже ссылается на новый объект. Меняется значение нового объекта.

В чем смысл конструкции ``this``?  
Перечислите случаи, когда используется конструкция ``this``.  
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?  
**Ответ.** ``this`` - это ссылка на текущий объект. Если в методе объявлена локальная переменная или параметр метода с таким же именем, как и поле класса, то для обращения
к полю класса использование ``this`` обязательно. Без использования указателя обращение всегда будет производиться к локальной переменной,
так как просто не существует другого способа ее идентификации.
1.	Когда у переменной экземпляра класса и аргумента метода/конструктора одинаковые имена;Можно обойтись без this если задать имена параметров отличные от имен полей класса.  
2.	Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из другого. Это еще называется явным вызовом конструктора. Можно не вызывать данный конструктор, но тогда будет копипаст кода така как придется переписать код нужного конструктора.    
3.  Используется для возврата ссылки на текущий объект (``return this``).Заменить нельзя.   
4.  Внутри логичесткого блока , при работе с полями, которые еще не были инициализированы, доступ к ним может быть получен только при использовании ``this`` .  


**Источник.** И. Блинов. Глава 3.

Можно ли присвоить null ссылочной переменной this?  
**Ответ.** Нет.При использовании в качестве основного выражения ключевое слово this обозначает значение, которое является ссылкой на объект, для которого был вызван метод экземпляра или метод по умолчанию, или ссылкой на создаваемый объект.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.8.3

Перечислите случаи, когда используется статический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.** Статические блоки могут применяться для проверки и инициализации базовых параметров, необходимых для функционирования приложения или класса.Так же применяется для инициализации статических переменных.   
Вместо статического блока можно вызывать статический метод при создании объекта.  
**Источник.** И.Н. Блинов, В.С. Романчик. Java from EPAM : учеб.-метод.       
 
Перечислите случаи, когда используется логический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.** Использование логического блока инициализации гарантирует, что такой блок будет выполнен по мере появления в коде в момент создания объекта класса.
Значение поля не удобно вычислять с помощью выражения (например, для этого нужен специально созданный класс или метод, который не хочется создавать только для этих целей).
Необходимо инициализировать поле анонимного класса (в анонимном классе невозможно объявить конструктор).
Возможна инициализация полей в конструкторе или в месте объявления.    
**Источник.** http://www.quizful.net/post/java-fields-initialization

Что входит в сигнатуру метода?  
**Ответ.** Имя метода плюс типы параметров(причем порядок типов параметров имеет значение). В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения.  
**Источник.** https://javarush.ru/groups/posts/1249-signatura-metoda

Что значит ключевое слово ``native``?  
**Ответ.** Модификатор ``native`` сигнализирует о том, что метод реализован в платформо-зависимом коде, часто на языке С++.  
**Источник.** И. Блинов. Глава 3.

Дан код. 
```java
public class BusinessTrip {
  …
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}
```
Есть ли в нем семантическая ошибка?
Если да, то обоснуйте.  
**Ответ.** Метод лучше перенести в утилитный класс и сделать его ``public static``. ``static`` для того,чтоб не приходилось создавать объект класса для доступа к методу.     
**Источник.** https://renkport.ru/java/osnova/prioritet-operatsij

Дан код. 
```java
public class Utility {
  private Utility() {
  }
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}
```
Есть ли в нем семантическая ошибка?
Если да, то предложите альтернативные варианты.  
**Ответ.** Да
```java
public class Utility {
  public static String bynToStr(int value) {
    return String.format("%d.%02d", value / 100, value % 100);
  }
}
```

К каким данным можно обратиться в статическом методе?    
**Ответ.** К статическим методам и полям, к локальным переменным метода и к аргументам метода. По причине недоступности указателя this статические поля и методы не
могут обращаться к нестатическим полям и методам напрямую, так как они не «знают», к какому объекту относятся, да и сам экземпляр класса может быть не создан.    
**Источник.** И.Н. Блинов, В.С. Романчик. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик. — Минск: Четыре четверти, 2020. — 560 с.

Почему нельзя обьявить статическое поле внутри метода?    
**Ответ.** Статические переменные могут быть созданы только, как переменные класса. Они не могут быть локальными переменными потому что локальная переменная может иметь только final модификатор (IDEA выдаст ошибку Modifier 'static' not allowed here или java: illegal start of expression)  
**Источник.** https://topjava.ru/blog/rukovodstvo-po-modifikatoru-static-v-java  

Перечислите, какой код в классе можно выполнить до создания обьекта  
**Ответ.** Статический блок инициализации.
Логический блок инициализации.
Статические члены класса.  
**Источник.** https://javarush.ru/groups/posts/2137-porjadok-deystviy-pri-sozdanii-obhhekta
 
В чем различие между объектом и экземпляром класса?  
**Ответ.** Объект — обладающий именем набор данных (полей и свойств объекта), физически находящихся в памяти компьютера, и методов, имеющих доступ к ним. Имя используется для работы с полями и методами объекта. Любой объект относится к определенному классу. В классе дается обобщенное описание некоторого набора родственных объектов. Объект — конкретный экземпляр класса. Класс — это шаблон для создания объекта.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.

Назовите три этапа создания экземпляра класса.  
**Ответ.** Если мы хотим создать объект (экземпляр класса), то мы должны создать класс, содержащий метод ``main()``, внутри которого и происходит выполнение программы.
Создание объекта состоит из трёх этапов:  
1.Декларация  
Декларирование переменной типа класса с уникальным именем.  
2.Инстанциация                                                           
Создание нового объекта с использованием ключевого слова ``new``.           
3.Инициализация             
Вызов конструкторов, который идёт после ключевого слова ``new``.  

**Источник.** https://proselyte.net/tutorials/java-core/classes-and-objects/
 
Охарактеризуйте отношение композиции между классами? Как оно реализуется?  
**Ответ.** При использовании композиции объект не только является частью какого-то объекта, но и не может принадлежать другому объекту того же типа. Самый простой пример — двигатель автомобиля. Двигатель является частью автомобиля, но не может быть частью другого автомобиля.
```java
class A {
    int a; // внутренняя переменная класса A

    // конструктор
    A() {
        a = 1;
    }

    // методы класса A
    void setA(int a) {
        this.a = a;
    }

    int getA() {
        return a;
    }
}

public class B {
    int b; // внутренняя переменная класса B

    // композиция: в классе B объявляются объекты класса A
    A a1 = new A();
    A a2;

    // конструктор класса B
    B() {
        b = 0;
        a2 = new A();
        a2.SetA(15);
    }

    // методы доступа к внутренней переменной b
    void setB(int nb) {
        b = nb;
    }

    int getB() {
        return b;
    }

    public static void main(String[] args) {
        // композиция: в классе B объявляются объекты класса A
        B objB = new B(); // объект (екземпляр) класса B

        // демонстрация доступа
        int t;

        // доступ к объекту a2 класса A, в котором реализован метод getA()
        t = objB.a2.getA(); // t = 15

        // доступ к объекту a1 класса A
        t = objB.a1.getA(); // t = 1

        System.out.println(t);
    }
}
```  
**Источник.** https://www.bestprog.net/ru/2018/10/03/reusing-code-in-java-the-concept-of-composition-inheritance-delegation-the-keyword-extends-examples_ru/#q03
 
Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.
Предложите способы и подтвердите примерами.  
**Ответ.** Возврат массива значений.
```java
public static int[] something(){
    int number1 = 1;
    int number2 = 2;
    return new int[] {number1, number2};
}
```
Возврат с использованием коллекций 
```java
public static List something(){
        List<Integer> list = new ArrayList<Integer>();
        int number1 = 1;
        int number2 = 2;
        list.add(number1);
        list.add(number2);
        return list;
    } 
```

Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов.
Предложите способы и подтвердите примерами.  
**Ответ.** Можно использовать класс Pair:
```java
public Pair retrievDate(int a , double b){
        return new Pair(a,b);
    }
```
Возврат разных значений через массив объектов:
```java
private static Object[] f () 
{ 
     double x =1.0;  
     int y= 2 ;
     return new Object[]{Double.valueOf(x),Integer.valueOf(y)};  
}
```

Что такое иммутабельный объект? 
Опишите 2 способа создания иммутабельных объектов. 
Подсказка. Способ 1 - класс материала в classes2. 
Какой альтернативный? 
Подсказка - ключевое слово ``final`` для полей не использовать.  
Создайте иммутабельный класс для вещества по альтернативному способу.  
**Ответ.** Иммутабельный - это объект, который не позволяет изменять свои параметры.  
Способ 1: сделать поля класса final.  
Способ 2: сделать так чтобы невозможно было получить ссылку на изменяемые объекты внутри immutable object, например возвращать копию данных.
```java
public class Material {
    private String name;
    private double density;
    
    public Material(String name, double density) {
        this.name = getImmutableName();
        this.density = getImmutableDensity();
    }

    public String getName() {
        return new String(name);
    }

    public double getDensity() {
        return new Double(density);
    }
}
```  
**Источник.** https://overcoder.net/q/968817/как-сделать-класс-неизменяемым-в-java-с-полем-даты-в-нем.

Даны 2 класса.
```java
final class Material {
	private final String name;
	private final double density;
	...
}
class Runner {
	private static void printMaterial(final Material material) {
        	System.out.println(material);
	}
	public static void main(String[] args) {
        	Material steel = new Material("steel",7850);
        	printMaterial(steel);
	}
}
```
В методе ``printMaterial()`` по ссылке material создается новый объект или имеется доступ к объекту ``new Material("steel",7850)``? 
Какой пример можно использовать для обоснования ответа?  
**Ответ.**  Мы передаем в метод ``printMaterial`` наш объект ``material``
            (а если точнее копию ссылки на область в памяти где он находится)
            Метод принимает данный объект и присваевает своей внутренней ссылке ``material`` копию ссылки на переданный объект. 
            И выводит именно именно этот объект.                   
Для доказательста можно использовать данный пример.   
```Java
class Runner {
    private static void printMaterial(final Material material) {
        System.out.println(material);
    }
    public static void main(String[] args) {
        Material steel = new Material("steel",7850);
        System.out.println(steel);
        printMaterial(steel);
    }
}
```
В результате выполнения программы будут выведены две строки с хэшкодом данного объекта, и они будут одинаковы.  

Класс для комплексного числа содержит два поля:
```Java
class Complex {
    private double re;
    private double im;
…
}
```
Реализуйте в данном классе методы: plus() для операции + и add() для +=.
Приведите пример использования каждого метода.
Реализуйте эти же методы при условии, что класс Complex является иммутабельным.  
**Ответ.**
```Java
public Complex plus(Complex number){
        return new Complex(re+number.re,im+number.im);
        }
public Complex add(Complex number){
        re+=number.re;
        im+=number.im;
        return this;
        }
        
```
Иммутабельный:
```Java
private final double re;
private final double im;

public Complex plus(Complex number)// остается таким же

public Complex add(Complex number)// нельзя реализрвать т.к. класс иммутабельный
```

Для чего предназначен метод ``toString()``?
В каких случаях он вызывается?  
**Ответ.** toString метод используется для получения строкового представления объекта. Каждый раз, когда мы пытаемся вывести ссылку на Object, вызывается метод ``toString()``. Если мы не определили в классе метод ``toString()``, то будет вызван метод ``toString()`` класса ``Object``.  
**Источник.** https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#toString()

Как реализован метод ``toString()`` в классе ``Object``?  
**Ответ.** ``toString()`` Метод класса ``Object`` возвращает строку , состоящую из имени класса которого объект является экземпляром, на-знак символ ` @ ` и беззнаковое шестнадцатеричное представление хэш - кода объекта. Другими словами, этот метод возвращает строку, равную значению: ``getClass (). getName () + '@' + Integer.toHexString (hashCode ())``  
**Источник.** https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#toString()

Для чего предназначен метод ``equals()``?
В каких случаях он вызывается?  
**Ответ.** Метод ``equals`` предназначен для сравнения объектов. Метод ``equals()`` указывает, равен ли какой-либо другой объект объекту у которого вызывается этот метод. 
 При этом сравниваются не ссылки на эти объекты, а его составляющая (класс, поля).    
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)

Как реализован метод equals() в классе Object?  
**Ответ.** Реализация метода в классе Object возвращает
истину только в том случае, если обе ссылки указывают на один и тот же объект,
а конкретно:
```java
public boolean equals(Object obj) {
    return (this == obj);
}
```
**Источник.** Блинов И.Н., Романчик В.С. Java from EPAM - с.139         

В чем различие между методом ``equals()`` и операции ``==``?
В каких случаях применение метода ``equals()`` и операции ``==`` эквивалентно?  
**Ответ.** ```==```  является ссылочным сравнением, то есть оба объекта указывают на одно и то же место памяти ``equals()``  оценивает сравнение значений в объектах. применение метода ``equals()`` и операции ``==`` эквивалентно для примитивных типов данных.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.

Eclipse в стандартной конфигурации генерирует начало метода ``equals()`` следующим образом:
```java
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
```
С чем связаны данные проверки, которые кажутся лишними?  
**Ответ.** Реализация метода ``equals()`` в классе ``Object`` возвращает истину только в том случае, если обе ссылки указывают на один и тот же объект.
При переопределении метода ``equals()`` должны выполняться соглашения,
предусмотренные спецификацией языка Java, а именно:     
• рефлексивность — объект равен самому себе;  
• ненулевая ссылка при сравнении с литералом ``null`` всегда возвращает значение ``false``.    
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.

Что такое garbage collection?  
**Ответ.** garbage collection – это сборщик мусора (система автоматического освобождения памяти)  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.

Перечислите случаи, когда JVM отдает управление на garbage collector  
**Ответ.**  Когда никаких ссылок на объект не существует, т. е. все ссылки на него вышли из области видимости программы, предполагается, что объект больше не нужен, и память, занятая объектом, может быть освобождена  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.

Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?  
**Ответ.** Форсировать «сборку мусора» невозможно, можно лишь «рекомендовать» выполнить ее вызовом метода ``System.gc()`` или ``Runtime.getRuntime().gc()``, но виртуальная машина выполнит очистку памяти тогда, когда сама посчитает это удобным.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.


Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти?
Обоснуйте ответ.    
**Ответ.** Не гарантирует что всегда будет оставаться достаточно памяти. Т.к если ссылки на объекты будут использоваться он их не удалит. В итоге если память будет переполнена  JVM генерирует исключение  OutOfMemoryError.  
**Источник.** И. Блинов. Java. Методы программирования. с. 118.     

Для чего предназначен метод finalize()?
Какой недостаток у метода?  
**Ответ.** Если объект взаимодействует с какими-то ресурсами, например открывает поток вывода и читает из него, то такой поток необходимо закрыть перед удалением объекта из памяти. 
           Для этого в языке Java достаточно переопределить метод ``finalize()``, который вызывается в исполняющей среде Java непосредственно перед удалением объекта данного класса. 
           В теле метода ``finalize()`` нужно указать те действия, которые должны быть выполнены перед уничтожением объекта. Метод ``finalize()`` вызывается лишь непосредственно перед сборкой "мусора"(уничтожением объекта).  
           Недостаток - метод ``finalize()`` не вызывается при выходе объекта из области действия. Заранее неизвестно, когда будет (и будет ли вообще) выполняться метод ``finalize()``.  
**Источник.** https://javarush.ru/quests/lectures/questsyntax.level06.lecture03 ; https://habr.com/ru/post/183344/ ; https://www.examclouds.com/ru/java/java-core-russian/metod-finalize

Для чего предназначены оболочечные классы?  
Как они называются на инглише?  
**Ответ.** Примитивы и их аналоги, классы оболочки, существуют параллельно, потому что у каждого есть преимущества.
           Например, обычный ``int`` занимает меньше места, и если нет необходимости проводить над ним особые операции, Ваш компьютер будет работать быстрее.
           В свою очередь, с помощью класса-оболочки ``Integer`` можно выполнять специальные операции - например, перевести текст в число (с помощью метода ``.parseInt()``). 
           Если попробовать сделать это с помощью кода самому придется изрядно повозиться.
           На инглише они называются - class wrappers.  
**Источник.** https://vertex-academy.com/tutorials/ru/klassy-obolochki-v-java/

В чем преимущество примитивных типов перед соответствующими оболочечными классами?  
**Ответ.**  Примитивные типы занимают меньше места в памяти, у примитивных типов нет литералла ``null``, также использование примитивных типов улучшает производительность.  
**Источник.** https://vertex-academy.com/tutorials/ru/klassy-obolochki-v-java/

Что такое autoboxing и unboxing?  
**Ответ.** Autoboxing - Это автоматическая инкапсуляция примитивного типа в эквивалентную ему класс-обёртку всякий раз, когда требуется объект данного типа.
           Autoboxing происходит:  
           1. При присвоении значения примитивного типа переменной соответствующего класса-обёртки.  
           2. При передаче примитивного типа в параметр метода, ожидающего соответствующий ему класс-обёртку.  
           Unboxing - Это преобразование класса-обёртки в соответствующий ему примитивный тип. Если при распаковке класс-обёртка был равен ``null``, произойдет исключение ``java.lang.NullPointerException``.
           Unboxing происходит:  
           1. При присвоении экземпляра класса-обёртки переменной соответствующего примитивного типа.  
           2. В выражениях, в которых один или оба аргумента являются экземплярами классов-обёрток (кроме операции ``==`` и ``!=``).  
           3. При передаче объекта класса-обёртки в метод, ожидающий соответствующий примитивный тип.  
**Источник.** https://habr.com/ru/post/329498/


Дан код:
```java
Integer a = 3, b =7;
Long c = a + b;
```
Перечислите все операции, где задействованы autoboxing и unboxing.  
**Ответ.** Long c = (long)(a + b);  
Операции:  
Integer a =new Integer(3);  
Integer b =new Integer(7);  
Long c = new Long(c1);  
int a1 = a.intValue();  
int b1 = b.intValue();  
Long c = new Long(c1);   

Дан корректный раннер-класс.
Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()?
Обоснуйте ответ.
Что произойдет, если отправить на выполнение измененный класс?  
**Ответ.** Ошибки компиляции не будет. Метод `Main()` станет методом экземпляра класса .        
`Main method is not static in class ClassName, please define the main method as: public static void main(String[] args)`


Дан класс.
```java
class Runner {
public static void main(String[] args) {
System.out.println("Hello, world!");
    }
}
```
Запрещается изменять синий код, т.е. метод main().
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:
I am java.
Hello, world!  
**Ответ.**
```Java
public class Runner {
    static {
        System.out.println("I am Java");
        }
    public static void main(String[] args) {
        System.out.println("Hello world");
}
```










